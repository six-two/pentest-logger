import os
from typing import Optional

# local files
from pt_helper import (
    Command,
    ProcessedCommand,
    ParamManipulator,
    ParamInfo,
    Settings,
    ProxySettings,
    debug,
)
from pt_helper.utils import command_contains_argument, get_timestamp_string, ArgumentRater, ARG_CONTAINS_MATCH


class ToolWrapper:
    """
    This is the class, that all tools should extend.
    Most tools should use the BaseToolWrapper, since it already has a few default functions implemented.
    """

    def __init__(self, settings: Settings) -> None:
        self.settings = settings

    def process_command(self, cmd: Command) -> ProcessedCommand:
        """
        The main function of a tool's wrapper.
        Rewrites the command and does some other calculations, then returns the results.
        """
        raise Exception("You need to override this method")


class BaseToolWrapper(ToolWrapper):
    def __init__(
        self,
        settings: Settings,
        flag_blocklist: list[str],
        proxy_param: Optional[ParamInfo],
        argument_target_pattern_list: Optional[list[str]],
        should_log_output: bool = True,
        should_log_arguments: bool = True,
        add_at_the_front: bool = False,
    ) -> None:
        super().__init__(settings)
        self.flag_blocklist = flag_blocklist
        self.proxy_param = proxy_param
        self.should_log_output = should_log_output
        self.should_log_arguments = should_log_arguments
        self.add_at_the_front = add_at_the_front

        if argument_target_pattern_list != None:
            self.argument_rater = ArgumentRater(settings, argument_target_pattern_list)
        else:
            self.argument_rater = None

    def process_command(self, cmd: Command) -> ProcessedCommand:
        """
        A basic implementation of the process_command function.
        Can be customized by overwriting the different subfunctions.
        """
        output_dir = self.derive_output_dir(cmd)
        output_dir = os.path.join(self.settings.project_dir, output_dir)
        output_dir = os.path.abspath(output_dir)
        output_dir = os.path.realpath(output_dir)
        # Create this before rewriting the command
        os.makedirs(output_dir)

        rewritten_cmd = self.rewrite_command(cmd, output_dir)
        should_process = not command_contains_argument(cmd, self.flag_blocklist)
        return ProcessedCommand(
            rewritten_command=rewritten_cmd,
            original_command=cmd,
            should_process=should_process,
            should_log_output=self.should_log_output,
            should_log_arguments=self.should_log_arguments,
            output_dir=output_dir,
        )

    def derive_target(self, cmd: Command) -> Optional[str]:
        if self.argument_rater:
            result = self.argument_rater.match_arguments(cmd)
            if result.match_list:
                if result.match_level < ARG_CONTAINS_MATCH:
                    debug(f"Low confidence ({result.match_level}) in detected targets: {result.match_list}")
                else:
                    if len(result.match_list) > 1:
                        debug(f"Multiple matches with same level ({result.match_level}): {result.match_list}")
                    # Assume that the first argument is the target one
                    return result.match_list[0].replace("/", "_")
        return None

    def derive_output_dir(self, cmd: Command) -> str:
        """
        A hook to change the output dir.
        Can be used, to create folders per target (hostname, ip, etc)
        """
        # debug(f"BaseToolWrapper: {vars(self)}")
        target = self.derive_target(cmd)

        if target:
            path = [cmd.name, target, get_timestamp_string()]
        else:
            path = [cmd.name, get_timestamp_string()]
        return os.path.join(*path)

    def proxy_format(self, proxy: ProxySettings) -> list[str]:
        """
        How to format the value for the proxy parameter.
        Returns a list to enable formats like ["localhost", "8080"].
        Defaults to the standard "localhost:8080" format
        """
        return [f"{proxy.host}:{proxy.port}"]

    def rewrite_command(self, cmd: Command, output_dir: str) -> Command:
        """
        Rewrite the command. By default, this just calls "rewrite_arguments_custom" and "rewrite_arguments_default"
        """
        if self.argument_rater:
            cmd = self.argument_rater.remove_target_specifiers(cmd)

        params = ParamManipulator(cmd.args)

        self.rewrite_arguments_custom(params, output_dir)
        self.rewrite_arguments_default(params, output_dir)
        return cmd._replace(args=params.args)

    def rewrite_arguments_custom(
        self, params: ParamManipulator, output_dir: str
    ) -> None:
        """
        Overwrite this to do custom argument rewriting, while keeping the default rewriting too.
        """
        pass

    def rewrite_arguments_default(
        self, params: ParamManipulator, output_dir: str
    ) -> None:
        """
        Does some basic and common argument rewriting (like setting the proxy)
        """
        proxy = self.settings.proxy
        debug(f"Checking if should add proxy: {self.proxy_param} {proxy}")
        if self.proxy_param and proxy.enabled:
            proxy_value = self.proxy_format(proxy)
            params.add_if_unset(self.proxy_param, proxy_value, self.add_at_the_front)
