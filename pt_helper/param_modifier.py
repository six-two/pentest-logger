from typing import NamedTuple, Optional

class MalformedParameterException(Exception):
    pass

class ValueCountMismatch(Exception):
    pass

class ParamInfo:
    def __init__(self, name: str, aliases: list[str] = [], value_count: int = 1):
        self.names = [name, *aliases]
        self.value_count = value_count

    def check_value(self, values: list[str]) -> None:
        if len(values) != self.value_count:
            raise ValueCountMismatch(f"Expected {self.value_count} argument(s), but got {len(values)}. Value array: {values}")

class ParamManipulator:
    def __init__(self, args: list[str]) -> None:
        self.args = [*args]

    def _range_insert(self, offset: int, values: list[str]):
        self.args = self.args[:offset] + values + self.args[offset:]

    def _range_remove(self, offset: int, length: int) -> list[str]:
        end = offset + length
        removed = self.args[offset:end]
        self.args = self.args[:offset] + self.args[end:]
        return removed

    def contains(self, param: ParamInfo) -> bool:
        return self.index_of(param) != None

    def get(self, param: ParamInfo) -> Optional[str]:
        index = self.index_of(param)
        if index != None:
            start = index + 1 # Operate after the argument name
            end = start + param.value_count
            return self.args[start:end]
        else:
            return None

    def index_of(self, param: ParamInfo) -> Optional[int]:
        for index, arg in enumerate(self.args):
            if arg in param.names:
                # Sanity check: param can have the required number of values
                if index + param.value_count < len(self.args):
                    return index
                else:
                    raise MalformedParameterException()
        return None

    def add(self, param: ParamInfo, values: list[str], add_at_the_front: bool = False) -> None:
        param.check_value(values)
        if add_at_the_front:
            self.args = [param.names[0], *values] + self.args
        else:
            self.args += [param.names[0], *values]

    def add_if_unset(self, param: ParamInfo, values: list[str], add_at_the_front: bool = False) -> bool:
        """
        Adds a param, only it it is not already set. Will return true, if the parameters were modified.
        """
        param.check_value(values)
        unset = not self.contains(param)
        if unset:
            self.add(param, values, add_at_the_front)
        return unset

    # def insert(self, index: int, param: ParamInfo, values: list[str]) -> None:
    #     self.args = self.args[:index] + [name, *values] + self.args[index:]

    def remove(self, param: ParamInfo) -> list[str]:
        index = self.index_of(param)
        if index is None:
            return []
        else:
            return self._range_remove(index, 1 + param.value_count)

    def replace(self, param: ParamInfo, values: list[str], add_at_the_front: bool = False) -> list[str]:
        """
        Replace the value of a parameter. Will return the old value (if available)
        """
        param.check_value(values)
        index = self.index_of(param)
        if index == None:
            self.add(param, values, add_at_the_front)
            return []
        else:
            index += 1 # Keep the original param name, perform all operations on the values after it
            result = self._range_remove(index, param.value_count)
            self._range_insert(index, values)
            return result

